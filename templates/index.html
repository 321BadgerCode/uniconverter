<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>File Converter</title>
	<link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
	<div class="container">
		<h1>Universal File Converter</h1>

		<!-- Upload area -->
		<div id="drop-zone" class="drop-zone">Drag & Drop File Here</div>
		<button onclick="clearAll()">Clear all</button>
		<div id="file-container"></div>
		<input type="file" id="fileInput" accept="image/*,video/*,audio/*,.pdf,.txt" hidden/>
		<input type="file" id="folderInput"  webkitdirectory directory multiple hidden>

		<!-- Conversion area -->
		<select id="formatSelect" disabled>
			<option value="">Select conversion format</option>
		</select>
		<button id="convertBtn" disabled>Convert</button>
	</div>

	<script>
		// Get elements
		const dropZone = document.getElementById("drop-zone");
		const fileInput = document.getElementById("fileInput");
		const folderInput = document.getElementById("folderInput");
		const formatSelect = document.getElementById("formatSelect");
		const convertBtn = document.getElementById("convertBtn");
		let files = [];
		let currentType = null;

		// Define supported formats
		const formatOptions = {
			image: ["jpg", "jpeg", "png", "webp", "gif", "bmp", "ico", "svg"],
			audio: ["mp3", "wav", "flac", "aac", "m4a", "ogg"],
			video: ["mp4", "mov", "avi", "webm", "mkv", "flv", "wmv"],
			document: ["pdf", "txt"]
		};

		/**
		 * @brief Creates file item.
		 * @param {File} file - The file to be displayed.
		 */
		function createFileItem(file) {
			// Add file to the list
			files.push(file);

			// Create a new file input and preview area
			const fileContainer = document.getElementById("file-container");
			const newFileDiv = document.createElement("div");
			newFileDiv.className = "file-item";
			newFileDiv.id = file.name.replace(/\s+/g, '_').toLowerCase();
			newFileDiv.style.position = "relative";
			newFileDiv.style.display = "inline-block";
			fileContainer.appendChild(newFileDiv);
			const previewDiv = document.createElement("div");
			previewDiv.id = "preview";
			previewDiv.style.marginTop = "20px";
			newFileDiv.appendChild(previewDiv);
			const clearBtn = document.createElement("button");
			clearBtn.textContent = "X";
			clearBtn.style.fontSize = "30px";
			clearBtn.style.backgroundColor = "transparent";
			clearBtn.style.color = "red";
			clearBtn.style.border = "none";
			clearBtn.style.position = "absolute";
			clearBtn.style.paddingLeft = "0px";
			clearBtn.style.top = "0";
			clearBtn.addEventListener("click", () => {
				files = files.filter(f => f.name !== file.name);
				currentType = files.length > 0 ? files[0].type.split('/')[0] : null;
				fileContainer.removeChild(newFileDiv);
			});
			newFileDiv.appendChild(clearBtn);

			// Set current type based on file type
			currentType = file.type.split('/')[0];
		}

		// Set up event listeners
		dropZone.addEventListener("dblclick", () => folderInput.click());
		dropZone.addEventListener("click", () => {
			setTimeout(() => {
				if (!dropZone.classList.contains("active")) {
					fileInput.click();
				}
			}, 200);
		});

		dropZone.addEventListener("dragover", e => {
			e.preventDefault();
			dropZone.classList.add("active");
		});

		dropZone.addEventListener("dragleave", () => {
			dropZone.classList.remove("active");
		});

		dropZone.addEventListener("drop", async e => {
			// Prevent default behavior and remove active class
			e.preventDefault();
			dropZone.classList.remove("active");

			// Add drag and drop functionality
			const file = e.dataTransfer.files[0];
			if (!file || file.type === '' || formatOptions[file.type.split('/')[0]] === undefined) {
				return;
			}

			// If the file is of a different type than the current type, show a warning
			if (files.length > 0 && currentType && file.type.split('/')[0] !== currentType) {
				alert("You are uploading a different type of file. The conversion files must be of type \"" + currentType + "\".");
				return;
			}

			// Create file item and upload
			createFileItem(file);
			await uploadFile(file);
		});

		fileInput.addEventListener("change", async () => {
			// Get file
			if (fileInput.files.length === 0) return;
			const file = fileInput.files[0];
			if (!file || file.type === '' || formatOptions[file.type.split('/')[0]] === undefined) {
				return;
			}

			// If the file is of a different type than the current type, show a warning
			if (files.length > 0 && currentType && file.type.split('/')[0] !== currentType) {
				alert("You are uploading a different type of file. The conversion files must be of type \"" + currentType + "\".");
				return;
			}

			// Create file item and upload
			createFileItem(file);
			await uploadFile(file);
		});

		folderInput.addEventListener("change", async () => {
			// Get files from folder input
			const folderFiles = Array.from(folderInput.files);
			if (folderFiles.length === 0) return;

			// Create file items and upload each file
			for (const file of folderFiles) {
				if (currentType && file.type.split('/')[0] !== currentType) {
					continue;
				}
				createFileItem(file);
				await uploadFile(file);
			}
		});

		formatSelect.addEventListener("change", () => {
			const ready = formatSelect.value && files.length > 0;
			convertBtn.disabled = !ready;
			convertBtn.classList.toggle("active", ready);
		});

		convertBtn.addEventListener("click", async () => {
			console.log(files);
			const formData = new FormData();
			for (const file of files) {
				formData.append("files", file);
			}
			formData.append("target_format", formatSelect.value);

			const res = await fetch("/convert", {
				method: "POST",
				body: formData
			});

			const blob = await res.blob();
			const url = URL.createObjectURL(blob);
			const link = document.createElement("a");
			link.href = url;
			if (files.length > 1) {
				link.download = `converted_files.zip`;
			} else {
				link.download = `${files[0].name.split('.').slice(0, -1).join('.')}_converted.${formatSelect.value}`;
			}
			link.click();
		});

		/**
		 * @brief Formats file size into a human-readable string.
		 * @param {number} size - The size of the file in bytes.
		 * @return {string} A formatted string representing the file size.
		 */
		function formatFileSize(size) {
			if (size < 1024) return `${size} B`;
			else if (size < 1048576) return `${(size / 1024).toFixed(2)} KB`;
			else if (size < 1073741824) return `${(size / 1048576).toFixed(2)} MB`;
			else if (size < 1099511627776) return `${(size / 1073741824).toFixed(2)} GB`;
			else return `${(size / 1099511627776).toFixed(2)} TB`;
		}

		/**
		 * @brief Uploads the selected file to the server and updates the UI.
		 * @param {File} file - The file to be uploaded.
		 */
		async function uploadFile(file) {
			// Get form data
			const formData = new FormData();
			formData.append("file", file);
			const res = await fetch("/upload", {
				method: "POST",
				body: formData
			});
			const data = await res.json();
			let uploadedFile = data.filename;
			let formatValue = formatSelect.value;

			// Update format select options
			if (data.type && formatOptions[data.type]) {
				formatSelect.innerHTML = `<option value="">Select format</option>`;
				formatOptions[data.type].forEach(fmt => {
					if (!uploadedFile.endsWith(fmt))
						formatSelect.innerHTML += `<option value="${fmt}">${fmt.toUpperCase()}</option>`;
				});
				// If it's a video, it can be converted to audio
				if (data.type === "video") {
					formatOptions.audio.forEach(fmt => {
						formatSelect.innerHTML += `<option value="${fmt}">${fmt.toUpperCase()}</option>`;
					});
				}
				// If there was a previous selection, keep it
				if (formatValue && formatOptions[data.type].includes(formatValue)) {
					formatSelect.value = formatValue;
				} else {
					formatSelect.value = "";
				}
				// Enable the format select
				formatSelect.disabled = false;
			} else {
				formatSelect.innerHTML = `<option value="">Unsupported file</option>`;
				formatSelect.disabled = true;
			}

			// Update convert button state
			if (data.type && formatOptions[data.type]) {
				convertBtn.classList.remove("active");
			}

			// Display file preview and info
			showPreview(file);
			const preview = document.getElementById("file-container").lastElementChild.querySelector("#preview");
			const fileInfo = document.createElement("div");
			fileInfo.textContent = `${file.name}, ${formatFileSize(file.size)} (${file.type})`;
			fileInfo.style.marginTop = "10px";
			fileInfo.style.fontSize = "14px";
			fileInfo.style.color = "#555";
			preview.appendChild(fileInfo);
		}

		/**
		 * @brief Displays a preview of the uploaded file based on its type.
		 * @param {File} file - The file to be previewed.
		 */
		function showPreview(file) {
			const preview = document.getElementById("file-container").lastElementChild.querySelector("#preview");
			preview.innerHTML = "";

			const ext = file.name.split('.').pop().toLowerCase();

			// Check file type and create appropriate preview
			if (formatOptions.image.includes(ext)) {
				const img = document.createElement("img");
				img.src = URL.createObjectURL(file);
				img.style.maxWidth = "100%";
				img.style.borderRadius = "8px";
				preview.appendChild(img);
			} else if (formatOptions.video.includes(ext)) {
				const video = document.createElement("video");
				video.src = URL.createObjectURL(file);
				video.controls = true;
				video.style.maxWidth = "100%";
				preview.appendChild(video);
			} else if (formatOptions.audio.includes(ext)) {
				const audio = document.createElement("audio");
				audio.src = URL.createObjectURL(file);
				audio.controls = true;
				preview.appendChild(audio);
			} else if (["txt"].includes(ext)) {
				const reader = new FileReader();
				reader.onload = function(e) {
					const text = e.target.result;
					let lines = text.split('\n').map(line => {
						return line.length > 50 ? line.substring(0, 50) + "..." : line;
					});
					if (lines.length > 30) {
						lines = lines.slice(0, 30);
						lines.push("...");
					}
					const pre = document.createElement("pre");
					pre.textContent = lines.join('\n');
					pre.style.whiteSpace = "pre-wrap";
					pre.style.wordBreak = "break-word";
					preview.appendChild(pre);
				};
				reader.readAsText(file);
			} else if (["pdf"].includes(ext)) {
				const pdfFrame = document.createElement("iframe");
				pdfFrame.src = URL.createObjectURL(file);
				pdfFrame.style.width = "100%";
				pdfFrame.style.height = "500px";
				preview.appendChild(pdfFrame);
			} else {
				preview.textContent = "Preview not available for this file type.";
			}
		}

		/**
		 * @brief Clears all uploaded files and resets the UI.
		 */
		function clearAll() {
			files = [];
			currentType = null;
			document.getElementById("file-container").innerHTML = "";
			formatSelect.innerHTML = `<option value="">Select conversion format</option>`;
			formatSelect.disabled = true;
			convertBtn.disabled = true;
			convertBtn.classList.remove("active");
			dropZone.classList.remove("active");
		}
	</script>
</body>
</html>